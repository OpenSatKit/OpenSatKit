        -:    0:Source:/home/aschoening/pwned/apps/cs/fsw/src/cs_utils.c
        -:    0:Graph:cs_utils.gcno
        -:    0:Data:cs_utils.gcda
        -:    0:Runs:1
        -:    0:Programs:9
        -:    1:/************************************************************************
        -:    2: ** File:
        -:    3: **   $Id: cs_utils.c.gcov 1.7 2012/09/14 17:20:45EDT aschoeni Exp  $
        -:    4: **
        -:    5: ** Purpose: 
        -:    6: **   The CFS Checksum (CS) Application's utility functions
        -:    7: **
        -:    8: **   $Log: cs_utils.c.gcov  $
        -:    8: **   Revision 1.7 2012/09/14 17:20:45EDT aschoeni 
        -:    8: **   Updated for fix to disable error in def table command
        -:    9: **   Revision 1.8 2012/06/06 14:43:33EDT lwalling 
        -:   10: **   Initialize variable DoneWithEntry
        -:   11: **   Revision 1.7 2011/09/06 11:52:34PDT jmdagost 
        -:   12: **   Corrected app-not-found and table-not-found compute event IDs.
        -:   13: **   Revision 1.6 2010/05/28 11:15:03EDT jmdagost 
        -:   14: **   Included cs_utils.h to eliminate potential compiler warnings.
        -:   15: **   Revision 1.5 2010/04/14 15:42:24EDT jmdagost 
        -:   16: **   Replaced CS_APP_TABLE with (CS_NUM_TABLES - 1) in CS_GoToNextTable().
        -:   17: **   Revision 1.4 2010/04/08 16:35:47EDT jmdagost 
        -:   18: **   Added conditional wrappers around background calculations for OS and cFE Core to check
        -:   19: **   the State value that has been set by the recompute command.
        -:   20: **   Revision 1.3 2010/03/29 16:55:57EDT jmdagost 
        -:   21: **   Replaced CS_GetTableEntryByName() and CS_GetAppEntryByName() with CS_GetTableResTblEntryByName() and CS_GetAppResTblEntryByName().
        -:   22: **   Added CS_GetTableDefTblByName() and CS_GetAppDefTblEntryByName().
        -:   23: **   Revision 1.2 2008/07/23 10:34:44EDT njyanchik 
        -:   24: **   Check in of CS Unit test
        -:   25: **   Revision 1.1 2008/06/13 09:04:24EDT njyanchik 
        -:   26: **   Initial revision
        -:   27: **   Member added to project c:/MKSDATA/MKS-REPOSITORY/CFS-REPOSITORY/cs/fsw/src/project.pj
        -:   28: ** 
        -:   29: *************************************************************************/
        -:   30:
        -:   31:/**************************************************************************
        -:   32: **
        -:   33: ** Include section
        -:   34: **
        -:   35: **************************************************************************/
        -:   36:#include "cfe.h"
        -:   37:#include "cs_app.h"
        -:   38:#include "cs_events.h"
        -:   39:#include "cs_compute.h"
        -:   40:#include "cs_utils.h"
        -:   41:#include <string.h>
        -:   42:
        -:   43:/**************************************************************************
        -:   44: **
        -:   45: ** Functions
        -:   46: **
        -:   47: **************************************************************************/
        -:   48:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   49:/*                                                                 */
        -:   50:/* CS Zero out the temp chcksum values of Eeprom                   */
        -:   51:/*                                                                 */
        -:   52:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   53:void CS_ZeroEepromTempValues(void)
function CS_ZeroEepromTempValues called 2 returned 100% blocks executed 100%
        2:   54:{
        -:   55:    uint16                                  Loop;
        -:   56:    
       34:   57:    for ( Loop = 0; Loop < CS_MAX_NUM_EEPROM_TABLE_ENTRIES; Loop++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:   58:    {
       32:   59:        CS_AppData.ResEepromTblPtr[Loop].TempChecksumValue = 0;
       32:   60:        CS_AppData.ResEepromTblPtr[Loop].ByteOffset = 0;
        -:   61:    }
        -:   62:    return;
        -:   63:}
        -:   64:
        -:   65:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   66:/*                                                                 */
        -:   67:/* CS Zero out the temp chcksum values of Memory                   */
        -:   68:/*                                                                 */
        -:   69:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   70:void CS_ZeroMemoryTempValues(void)
function CS_ZeroMemoryTempValues called 2 returned 100% blocks executed 100%
        2:   71:{
        -:   72:    uint16                                  Loop;
        -:   73:    
       34:   74:    for ( Loop = 0; Loop < CS_MAX_NUM_MEMORY_TABLE_ENTRIES; Loop++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:   75:    {
       32:   76:        CS_AppData.ResMemoryTblPtr[Loop].TempChecksumValue = 0;
       32:   77:        CS_AppData.ResMemoryTblPtr[Loop].ByteOffset = 0;
        -:   78:    }
        -:   79:    
        -:   80:    return;
        -:   81:}
        -:   82:
        -:   83:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   84:/*                                                                 */
        -:   85:/* CS Zero out the temp chcksum values of Tables                   */
        -:   86:/*                                                                 */
        -:   87:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:   88:void CS_ZeroTablesTempValues(void)
function CS_ZeroTablesTempValues called 2 returned 100% blocks executed 100%
        2:   89:{
        -:   90:    uint16                                  Loop;
        -:   91:    
       50:   92:    for ( Loop = 0; Loop < CS_MAX_NUM_TABLES_TABLE_ENTRIES; Loop++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:   93:    {
       48:   94:        CS_AppData.ResTablesTblPtr[Loop].TempChecksumValue = 0;
       48:   95:        CS_AppData.ResTablesTblPtr[Loop].ByteOffset = 0;
        -:   96:    }
        -:   97:    
        -:   98:    return;
        -:   99:}
        -:  100:
        -:  101:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  102:/*                                                                 */
        -:  103:/* CS Zero out the temp chcksum values of Applications             */
        -:  104:/*                                                                 */
        -:  105:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  106:void CS_ZeroAppTempValues(void)
function CS_ZeroAppTempValues called 2 returned 100% blocks executed 100%
        2:  107:{
        -:  108:    uint16                                  Loop;
        -:  109:    
       50:  110:    for ( Loop = 0; Loop < CS_MAX_NUM_APP_TABLE_ENTRIES; Loop ++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  111:    {
       48:  112:        CS_AppData.ResAppTblPtr[Loop].TempChecksumValue = 0;
       48:  113:        CS_AppData.ResAppTblPtr[Loop].ByteOffset = 0;
        -:  114:    }
        -:  115:    
        -:  116:    return;
        -:  117:}
        -:  118:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  119:/*                                                                 */
        -:  120:/* CS Zero out the temp chcksum values ofthe cFE core              */
        -:  121:/*                                                                 */
        -:  122:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  123:void CS_ZeroCfeCoreTempValues(void)
function CS_ZeroCfeCoreTempValues called 3 returned 100% blocks executed 100%
        3:  124:{    
        3:  125:    CS_AppData.CfeCoreCodeSeg.TempChecksumValue = 0;
        3:  126:    CS_AppData.CfeCoreCodeSeg.ByteOffset = 0;    
        -:  127:    
        -:  128:    return;
        -:  129:}
        -:  130:
        -:  131:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  132:/*                                                                 */
        -:  133:/* CS Zero out the temp chcksum values of the OS code segment      */
        -:  134:/*                                                                 */
        -:  135:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  136:void CS_ZeroOSTempValues(void)
function CS_ZeroOSTempValues called 3 returned 100% blocks executed 100%
        3:  137:{    
        3:  138:    CS_AppData.OSCodeSeg.TempChecksumValue = 0;
        3:  139:    CS_AppData.OSCodeSeg.ByteOffset = 0;    
        -:  140:    
        -:  141:    return;
        -:  142:}
        -:  143:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  144:/*                                                                 */
        -:  145:/* CS Nullifies the entries in the Results table for All           */
        -:  146:/*                                                                 */
        -:  147:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  148:void CS_InitializeDefaultTables(void)
function CS_InitializeDefaultTables called 8 returned 100% blocks executed 100%
        8:  149:{
        -:  150:    uint16                                  Loop;
        -:  151:
      136:  152:    for (Loop = 0; Loop < CS_MAX_NUM_EEPROM_TABLE_ENTRIES; Loop++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  153:    {                
      128:  154:        CS_AppData.DefaultEepromDefTable[Loop].State              = CS_STATE_EMPTY;
      128:  155:        CS_AppData.DefaultEepromDefTable[Loop].NumBytesToChecksum = 0;
      128:  156:        CS_AppData.DefaultEepromDefTable[Loop].StartAddress       =0;
        -:  157:     
        -:  158:    }
        -:  159:           
      136:  160:    for (Loop = 0; Loop < CS_MAX_NUM_MEMORY_TABLE_ENTRIES; Loop++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  161:    {                
      128:  162:        CS_AppData.DefaultMemoryDefTable[Loop].State              = CS_STATE_EMPTY;
      128:  163:        CS_AppData.DefaultMemoryDefTable[Loop].NumBytesToChecksum = 0;
      128:  164:        CS_AppData.DefaultMemoryDefTable[Loop].StartAddress       = 0;
        -:  165:    }
        -:  166:    
      200:  167:    for (Loop = 0; Loop < CS_MAX_NUM_APP_TABLE_ENTRIES; Loop++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  168:    {                
      192:  169:        CS_AppData.DefaultAppDefTable[Loop].State              = CS_STATE_EMPTY;
      192:  170:        CS_AppData.DefaultAppDefTable[Loop].Name[0]            = '\0';        
        -:  171:    }
        -:  172:
        -:  173:
      200:  174:    for (Loop = 0; Loop < CS_MAX_NUM_TABLES_TABLE_ENTRIES; Loop++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  175:    {                
      192:  176:        CS_AppData.DefaultTablesDefTable[Loop].State              = CS_STATE_EMPTY;
      192:  177:        CS_AppData.DefaultTablesDefTable[Loop].Name[0]            = '\0';
        -:  178:    }
        -:  179:    
        -:  180:    return;
        -:  181:}/* end CS_InitializeDefaultTables */
        -:  182:
        -:  183:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  184:/*                                                                 */
        -:  185:/* CS Set the global variables to the start of the next table      */
        -:  186:/*                                                                 */
        -:  187:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  188:void CS_GoToNextTable(void)
function CS_GoToNextTable called 1806 returned 100% blocks executed 100%
     1806:  189:{    
     1806:  190:    if ( CS_AppData.CurrentCSTable < (CS_NUM_TABLES - 1))
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  191:    {
     1505:  192:        CS_AppData.CurrentCSTable++;
        -:  193:    }
        -:  194:    else
        -:  195:    {
      301:  196:        CS_AppData.CurrentCSTable = 0;
        -:  197:        /* we are back to the beginning of the tables to checksum
        -:  198:         we need to update the pass counter */
      301:  199:        CS_AppData.PassCounter++;
        -:  200:    }
        -:  201:    
     1806:  202:    CS_AppData.CurrentEntryInTable = 0;
        -:  203:    return;
        -:  204:}
        -:  205:
        -:  206:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  207:/*                                                                 */
        -:  208:/* CS Get the Results Table Entry info of a table by its name      */
        -:  209:/*                                                                 */
        -:  210:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  211:boolean CS_GetTableResTblEntryByName(CS_Res_Tables_Table_Entry_t ** EntryPtr,
        -:  212:                                     char* Name)
function CS_GetTableResTblEntryByName called 14 returned 100% blocks executed 100%
       14:  213:{
       14:  214:    CS_Res_Tables_Table_Entry_t           * StartOfResultsTable = NULL;
       14:  215:    CS_Res_Tables_Table_Entry_t           * ResultsEntry        = NULL; 
        -:  216:    int32                                   Loop;
        -:  217:    uint16                                  MaxEntries;
       14:  218:    boolean                                 Status              = FALSE;
        -:  219:    
        -:  220:    
       14:  221:    StartOfResultsTable = CS_AppData.ResTablesTblPtr;
       14:  222:    MaxEntries = CS_MAX_NUM_TABLES_TABLE_ENTRIES;
        -:  223:    
      134:  224:    for (Loop = 0; Loop < MaxEntries; Loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -:  225:    {
      130:  226:        ResultsEntry = & StartOfResultsTable[Loop];
        -:  227:        
      130:  228:        if (strncmp(ResultsEntry -> Name, Name,CFE_TBL_MAX_FULL_NAME_LEN) == 0  &&
call    0 returned 100%
branch  1 taken 8% (fallthrough)
branch  2 taken 92%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  229:            ResultsEntry -> State != CS_STATE_EMPTY)
        -:  230:        {
       10:  231:            Status      = TRUE;
       10:  232:            *EntryPtr   =  ResultsEntry;
       10:  233:            break;
        -:  234:        }
        -:  235:    }   
       14:  236:    return Status;
        -:  237:}/* end CS_GetTableResTblEntryByName */
        -:  238:
        -:  239:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  240:/*                                                                 */
        -:  241:/* CS Get the Defintion Table Entry info of a table by its name      */
        -:  242:/*                                                                 */
        -:  243:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  244:boolean CS_GetTableDefTblEntryByName(CS_Def_Tables_Table_Entry_t ** EntryPtr,
        -:  245:                                     char* Name)
function CS_GetTableDefTblEntryByName called 6 returned 100% blocks executed 100%
        6:  246:{
        6:  247:    CS_Def_Tables_Table_Entry_t           * StartOfDefinitionTable = NULL;
        6:  248:    CS_Def_Tables_Table_Entry_t           * DefinitionEntry           = NULL; 
        -:  249:    int32                                   Loop;
        -:  250:    uint16                                  MaxEntries;
        6:  251:    boolean                                 Status                 = FALSE;
        -:  252:    
        -:  253:    
        6:  254:    StartOfDefinitionTable = CS_AppData.DefTablesTblPtr;
        6:  255:    MaxEntries = CS_MAX_NUM_TABLES_TABLE_ENTRIES;
        -:  256:    
       66:  257:    for (Loop = 0; Loop < MaxEntries; Loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -:  258:    {
       64:  259:        DefinitionEntry = & StartOfDefinitionTable[Loop];
        -:  260:        
       64:  261:        if (strncmp(DefinitionEntry -> Name, Name,CFE_TBL_MAX_FULL_NAME_LEN) == 0  &&
call    0 returned 100%
branch  1 taken 6% (fallthrough)
branch  2 taken 94%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  262:            DefinitionEntry -> State != CS_STATE_EMPTY)
        -:  263:        {
        4:  264:            Status      = TRUE;
        4:  265:            *EntryPtr   =  DefinitionEntry;
        4:  266:            break;
        -:  267:        }
        -:  268:    }   
        6:  269:    return Status;
        -:  270:}/* end CS_GetTableDefTblEntryByName */
        -:  271:
        -:  272:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  273:/*                                                                 */
        -:  274:/* CS Get the Results Entry info of an app by its name             */
        -:  275:/*                                                                 */
        -:  276:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  277:boolean CS_GetAppResTblEntryByName(CS_Res_App_Table_Entry_t ** EntryPtr,
        -:  278:                                   char                    * Name)
function CS_GetAppResTblEntryByName called 14 returned 100% blocks executed 100%
       14:  279:{
       14:  280:    CS_Res_App_Table_Entry_t              * StartOfResultsTable = NULL;
       14:  281:    CS_Res_App_Table_Entry_t              * ResultsEntry        = NULL; 
        -:  282:    int32                                   Loop;
        -:  283:    uint16                                  MaxEntries;
       14:  284:    boolean                                 Status              = FALSE;
        -:  285:    
       14:  286:    StartOfResultsTable = CS_AppData.ResAppTblPtr;
       14:  287:    MaxEntries = CS_MAX_NUM_APP_TABLE_ENTRIES;
        -:  288:    
      184:  289:    for (Loop = 0; Loop < MaxEntries; Loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -:  290:    {
      178:  291:        ResultsEntry = & StartOfResultsTable[Loop];
        -:  292:        
      178:  293:        if (strncmp(ResultsEntry -> Name, Name, OS_MAX_API_NAME) == 0  &&
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  294:            ResultsEntry -> State != CS_STATE_EMPTY)
        -:  295:        {
        8:  296:            Status      = TRUE;
        8:  297:            *EntryPtr   =  ResultsEntry;
        8:  298:            break;
        -:  299:        }
        -:  300:    }   
       14:  301:    return Status;
        -:  302:}/* end CS_GetAppResTblEntryByName */
        -:  303:
        -:  304:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  305:/*                                                                 */
        -:  306:/* CS Get the Definition Entry info of an app by its name          */
        -:  307:/*                                                                 */
        -:  308:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  309:boolean CS_GetAppDefTblEntryByName(CS_Def_App_Table_Entry_t ** EntryPtr,
        -:  310:                                   char                    * Name)
function CS_GetAppDefTblEntryByName called 4 returned 100% blocks executed 100%
        4:  311:{
        4:  312:    CS_Def_App_Table_Entry_t              * StartOfDefinitionTable = NULL;
        4:  313:    CS_Def_App_Table_Entry_t              * DefinitionEntry        = NULL; 
        -:  314:    int32                                   Loop;
        -:  315:    uint16                                  MaxEntries;
        4:  316:    boolean                                 Status                 = FALSE;
        -:  317:    
        4:  318:    StartOfDefinitionTable = CS_AppData.DefAppTblPtr;
        4:  319:    MaxEntries = CS_MAX_NUM_APP_TABLE_ENTRIES;
        -:  320:    
       60:  321:    for (Loop = 0; Loop < MaxEntries; Loop++)
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -:  322:    {
       58:  323:        DefinitionEntry = & StartOfDefinitionTable[Loop];
        -:  324:        
       58:  325:        if (strncmp(DefinitionEntry -> Name, Name, OS_MAX_API_NAME) == 0  &&
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
        -:  326:            DefinitionEntry -> State != CS_STATE_EMPTY)
        -:  327:        {
        2:  328:            Status      = TRUE;
        2:  329:            *EntryPtr   = DefinitionEntry;
        2:  330:            break;
        -:  331:        }
        -:  332:    }   
        4:  333:    return Status;
        -:  334:}/* end CS_GetAppDefTblEntryByName */
        -:  335:
        -:  336:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  337:/*                                                                 */
        -:  338:/* CS Get the next CS-enabled entry of this table                  */
        -:  339:/*                                                                 */
        -:  340:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  341:boolean CS_FindEnabledEepromEntry(uint16* EnabledEntry)
function CS_FindEnabledEepromEntry called 719 returned 100% blocks executed 100%
      719:  342:{
      719:  343:    CS_Res_EepromMemory_Table_Entry_t       * StartOfResultsTable   = NULL;
      719:  344:    CS_Res_EepromMemory_Table_Entry_t       * ResultsEntry          = NULL;
      719:  345:    boolean                                   EnabledEntries        = TRUE;
        -:  346:    
        -:  347:    
      719:  348:    StartOfResultsTable = CS_AppData.ResEepromTblPtr;    
        -:  349:
      719:  350:    ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  351:    
     1983:  352:    while ( ResultsEntry -> State != CS_STATE_ENABLED)
branch  0 taken 45%
branch  1 taken 55% (fallthrough)
        -:  353:    {
      567:  354:        CS_AppData.CurrentEntryInTable++;
        -:  355:        
      567:  356:        if (CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_EEPROM_TABLE_ENTRIES)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  357:        {
        -:  358:            /* we reached the end no more enabled entries */
       22:  359:            EnabledEntries = FALSE;
       22:  360:            break;
        -:  361:        }
        -:  362:        
      545:  363:        ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  364:    }/* end while */
        -:  365:    
      719:  366:    *EnabledEntry = CS_AppData.CurrentEntryInTable;
        -:  367:    
      719:  368:    return EnabledEntries;
        -:  369:} /* end CS FindEnabledEepromEntry */
        -:  370:
        -:  371:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  372:/*                                                                 */
        -:  373:/* CS Get the next CS-enabled entry of this table                  */
        -:  374:/*                                                                 */
        -:  375:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  376:boolean CS_FindEnabledMemoryEntry(uint16* EnabledEntry)
function CS_FindEnabledMemoryEntry called 663 returned 100% blocks executed 100%
      663:  377:{
      663:  378:    CS_Res_EepromMemory_Table_Entry_t     * StartOfResultsTable     = NULL;
      663:  379:    CS_Res_EepromMemory_Table_Entry_t     * ResultsEntry            = NULL;
      663:  380:    boolean                                 EnabledEntries          = TRUE;
        -:  381:    
        -:  382:    
      663:  383:    StartOfResultsTable = CS_AppData.ResMemoryTblPtr;    
      663:  384:    ResultsEntry        = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  385:    
     1924:  386:    while ( ResultsEntry -> State != CS_STATE_ENABLED)
branch  0 taken 49%
branch  1 taken 51% (fallthrough)
        -:  387:    {
      620:  388:        CS_AppData.CurrentEntryInTable++;
        -:  389:        
      620:  390:        if (CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_MEMORY_TABLE_ENTRIES)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  391:        {
        -:  392:            /* we reached the end no more enabled entries */
       22:  393:            EnabledEntries = FALSE;
       22:  394:            break;
        -:  395:        }
        -:  396:        
      598:  397:        ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  398:    }/* end while */
        -:  399:    
      663:  400:    *EnabledEntry = CS_AppData.CurrentEntryInTable;
        -:  401:    
      663:  402:    return EnabledEntries;
        -:  403:} /* end CS FindEnabledMemoryEntry */
        -:  404:
        -:  405:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  406:/*                                                                 */
        -:  407:/* CS Get the next CS-enabled entry of this table                  */
        -:  408:/*                                                                 */
        -:  409:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  410:boolean CS_FindEnabledTablesEntry(uint16* EnabledEntry)
function CS_FindEnabledTablesEntry called 864 returned 100% blocks executed 100%
      864:  411:{
      864:  412:    CS_Res_Tables_Table_Entry_t       * StartOfResultsTable     = NULL;
      864:  413:    CS_Res_Tables_Table_Entry_t       * ResultsEntry            = NULL;
      864:  414:    boolean                             EnabledEntries          = TRUE;
        -:  415:    
      864:  416:    StartOfResultsTable = CS_AppData.ResTablesTblPtr;    
      864:  417:    ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  418:
     2740:  419:    while ( ResultsEntry -> State != CS_STATE_ENABLED)
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
        -:  420:    {
     1061:  421:        CS_AppData.CurrentEntryInTable++;
        -:  422:        
     1061:  423:        if (CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_TABLES_TABLE_ENTRIES)
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        -:  424:        {
        -:  425:            /* we reached the end no more enabled entries */
       49:  426:            EnabledEntries = FALSE;
        -:  427:
       49:  428:            break;
        -:  429:        }
        -:  430:        
     1012:  431:        ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  432:        
        -:  433:    }/* end while */
        -:  434:    
      864:  435:    *EnabledEntry = CS_AppData.CurrentEntryInTable;
        -:  436:    
      864:  437:    return EnabledEntries;
        -:  438:} /* end CS FindEnabledTablesEntry */
        -:  439:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  440:/*                                                                 */
        -:  441:/* CS Get the next CS-enabled entry of this table                  */
        -:  442:/*                                                                 */
        -:  443:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  444:boolean CS_FindEnabledAppEntry(uint16* EnabledEntry)
function CS_FindEnabledAppEntry called 1239 returned 100% blocks executed 100%
     1239:  445:{
     1239:  446:    CS_Res_App_Table_Entry_t          * StartOfResultsTable     = NULL;
     1239:  447:    CS_Res_App_Table_Entry_t          * ResultsEntry            = NULL;
     1239:  448:    boolean                             EnabledEntries          = TRUE;
        -:  449:    
     1239:  450:    StartOfResultsTable = CS_AppData.ResAppTblPtr;    
     1239:  451:    ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  452:    
        -:  453:
     3668:  454:    while ( ResultsEntry -> State != CS_STATE_ENABLED)
branch  0 taken 52%
branch  1 taken 48% (fallthrough)
        -:  455:    {
     1265:  456:        CS_AppData.CurrentEntryInTable++;
        -:  457:        
     1265:  458:        if (CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_APP_TABLE_ENTRIES)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  459:        {
        -:  460:            /* we reached the end no more enabled entries */
       75:  461:            EnabledEntries = FALSE;
       75:  462:            break;
        -:  463:        }
        -:  464:        
     1190:  465:        ResultsEntry = & StartOfResultsTable[ CS_AppData.CurrentEntryInTable];
        -:  466:        
        -:  467:    }/* end while */
        -:  468:    
     1239:  469:    *EnabledEntry = CS_AppData.CurrentEntryInTable;
        -:  470:    
        -:  471:    
     1239:  472:    return EnabledEntries;
        -:  473:} /* end CS FindEnabledAppEntry */
        -:  474:
        -:  475:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  476:/*                                                                 */
        -:  477:/* CS Verify the length of the command                             */
        -:  478:/*                                                                 */
        -:  479:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  480:boolean CS_VerifyCmdLength(CFE_SB_MsgPtr_t msg, 
        -:  481:                           uint16          ExpectedLength)
function CS_VerifyCmdLength called 128 returned 100% blocks executed 100%
      128:  482:{
        -:  483:    CFE_SB_MsgId_t MessageID;
        -:  484:    uint16  CommandCode;
      128:  485:    boolean Result = TRUE;
      128:  486:    uint16  ActualLength = CFE_SB_GetTotalMsgLength(msg);
call    0 returned 100%
        -:  487:    
        -:  488:    /* Verify the command packet length */
      128:  489:    if (ExpectedLength != ActualLength)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  490:    {
        1:  491:        CommandCode = CFE_SB_GetCmdCode(msg);
call    0 returned 100%
        1:  492:        MessageID= CFE_SB_GetMsgId(msg);
call    0 returned 100%
        -:  493:        
        1:  494:        CFE_EVS_SendEvent(CS_LEN_ERR_EID,
call    0 returned 100%
        -:  495:                          CFE_EVS_ERROR,
        -:  496:                          "Invalid msg length: ID = 0x%04X, CC = %d, Len = %d, Expected = %d",
        -:  497:                          MessageID,
        -:  498:                          CommandCode,
        -:  499:                          ActualLength,
        -:  500:                          ExpectedLength);
        1:  501:        Result = FALSE;
        1:  502:        CS_AppData.CmdErrCounter++;
        -:  503:    }    
      128:  504:    return(Result);
        -:  505:} /* End of CS_VerifyCmdLength */
        -:  506:
        -:  507:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  508:/*                                                                 */
        -:  509:/* Background check cFE core                                       */
        -:  510:/*                                                                 */
        -:  511:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  512:boolean CS_BackgroundCfeCore(void)
function CS_BackgroundCfeCore called 597 returned 100% blocks executed 100%
      597:  513:{
        -:  514:    CS_Res_EepromMemory_Table_Entry_t     * ResultsEntry;
      597:  515:    boolean                                 DoneWithCycle       = FALSE;
      597:  516:    boolean                                 DoneWithEntry       = FALSE;
      597:  517:    uint32                                  ComputedCSValue     = 0;
        -:  518:    int32                                   Status;
        -:  519:    
      597:  520:    if( CS_AppData.CfeCoreCSState == CS_STATE_ENABLED)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  521:    {
      594:  522:        ResultsEntry = & CS_AppData.CfeCoreCodeSeg;
        -:  523:        
        -:  524:        /* Check if the code segment state is enabled (could be disabled for
        -:  525:           a ground-commanded recompute) */
      594:  526:        if (ResultsEntry->State == CS_STATE_ENABLED)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
        -:  527:        {
        -:  528:        
        -:  529:            /* If we complete an entry's checksum, this function will update it for us */
      394:  530:            Status = CS_ComputeEepromMemory (ResultsEntry, &ComputedCSValue, &DoneWithEntry);
call    0 returned 100%
        -:  531:        
        -:  532:            /* We need to avoid the case of finishing a table, moving on to the next one
        -:  533:             and computing an entry in that table, since it could put us above the 
        -:  534:             maximum bytes per cycle */
      394:  535:            DoneWithCycle = TRUE;
        -:  536:        
      394:  537:            if(Status == CS_ERROR)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  538:            {
        -:  539:                /* we had a miscompare */
        -:  540:            
        2:  541:                CS_AppData.CfeCoreCSErrCounter++;                
        -:  542:            
        2:  543:                CFE_EVS_SendEvent (CS_CFECORE_MISCOMPARE_ERR_EID,
call    0 returned 100%
        -:  544:                                   CFE_EVS_ERROR,
        -:  545:                                   "Checksum Failure: cFE Core, Expected: 0x%08X, Calculated: 0x%08X",                                   
        -:  546:                                   ResultsEntry -> ComparisonValue,
        -:  547:                                   ComputedCSValue);
        -:  548:            }
        -:  549:        
      394:  550:            if (DoneWithEntry == TRUE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  551:            {
       98:  552:                CS_AppData.CurrentEntryInTable ++;
        -:  553:            }
        -:  554:        
        -:  555:            /* only one entry to do */
      394:  556:            if ( CS_AppData.CurrentEntryInTable > 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  557:            {
        -:  558:                /* We are done with this table */
       98:  559:                CS_AppData.CfeCoreBaseline = ResultsEntry -> ComparisonValue;
       98:  560:                CS_GoToNextTable();
call    0 returned 100%
        -:  561:            }
        -:  562:        }
        -:  563:        else 
        -:  564:        {
        -:  565:            /* Currently disabled, so skip it */
      200:  566:            CS_GoToNextTable();
call    0 returned 100%
        -:  567:        }
        -:  568:    }
        -:  569:    else /* Table is disabled, skip it */
        -:  570:    {
        3:  571:        CS_GoToNextTable();
call    0 returned 100%
        -:  572:    }
        -:  573:    
      597:  574:    return DoneWithCycle;
        -:  575:}/* end CS_BackgroundCfeCore */    
        -:  576:
        -:  577:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  578:/*                                                                 */
        -:  579:/* Background check OS                                             */
        -:  580:/*                                                                 */
        -:  581:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  582:boolean CS_BackgroundOS(void)
function CS_BackgroundOS called 595 returned 100% blocks executed 100%
      595:  583:{
        -:  584:    CS_Res_EepromMemory_Table_Entry_t     * ResultsEntry;
      595:  585:    boolean                                 DoneWithCycle       = FALSE;
      595:  586:    boolean                                 DoneWithEntry       = FALSE;
      595:  587:    uint32                                  ComputedCSValue     = 0;
        -:  588:    int32                                   Status;
        -:  589:    
      595:  590:    if( CS_AppData.OSCSState == CS_STATE_ENABLED)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  591:    {
      592:  592:        ResultsEntry = & CS_AppData.OSCodeSeg;
        -:  593:        
        -:  594:        /* Check if the code segment state is enabled (could be disabled for
        -:  595:         a ground-commanded recompute) */
      592:  596:        if (ResultsEntry->State == CS_STATE_ENABLED)
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
        -:  597:        {
        -:  598:            /* If we complete an entry's checksum, this function will update it for us */
      392:  599:            Status = CS_ComputeEepromMemory (ResultsEntry, &ComputedCSValue, &DoneWithEntry);
call    0 returned 100%
        -:  600:        
        -:  601:            /* We need to avoid the case of finishing a table, moving on to the next one
        -:  602:             and computing an entry in that table, since it could put us above the 
        -:  603:             maximum bytes per cycle */
      392:  604:            DoneWithCycle = TRUE;
        -:  605:        
      392:  606:            if(Status == CS_ERROR)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  607:            {
        -:  608:                /* we had a miscompare */
        2:  609:                CS_AppData.OSCSErrCounter++;                
        -:  610:            
        2:  611:                CFE_EVS_SendEvent (CS_OS_MISCOMPARE_ERR_EID,
call    0 returned 100%
        -:  612:                                   CFE_EVS_ERROR,
        -:  613:                                   "Checksum Failure: OS code segment, Expected: 0x%08X, Calculated: 0x%08X",                                   
        -:  614:                                   ResultsEntry -> ComparisonValue,
        -:  615:                                   ComputedCSValue);
        -:  616:            }
        -:  617:        
      392:  618:            if (DoneWithEntry == TRUE)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  619:            {
       98:  620:                CS_AppData.CurrentEntryInTable ++;
        -:  621:            }
        -:  622:        
        -:  623:            /* only one entry to do */
      392:  624:            if ( CS_AppData.CurrentEntryInTable > 0)
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -:  625:            {
        -:  626:                /* We are done with this table */
       98:  627:                CS_AppData.OSBaseline = ResultsEntry -> ComparisonValue;
       98:  628:                CS_GoToNextTable();
call    0 returned 100%
        -:  629:            }
        -:  630:        }
        -:  631:        else 
        -:  632:        {
        -:  633:            /* Currently disabled, so skip it */
      200:  634:            CS_GoToNextTable();
call    0 returned 100%
        -:  635:        }
        -:  636:    }
        -:  637:    else /* Table is disabled, skip it */
        -:  638:    {
        3:  639:        CS_GoToNextTable();
call    0 returned 100%
        -:  640:    }
      595:  641:    return DoneWithCycle;
        -:  642:    
        -:  643:}/* end CS_BackgroundOS */    
        -:  644:
        -:  645:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  646:/*                                                                 */
        -:  647:/* Background check Eeprom                                         */
        -:  648:/*                                                                 */
        -:  649:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  650:boolean CS_BackgroundEeprom(void)
function CS_BackgroundEeprom called 941 returned 100% blocks executed 100%
      941:  651:{
        -:  652:    CS_Res_EepromMemory_Table_Entry_t     * StartOfResultsTable;
        -:  653:    CS_Res_EepromMemory_Table_Entry_t     * ResultsEntry;
      941:  654:    boolean                                 DoneWithCycle           = FALSE;
      941:  655:    boolean                                 DoneWithEntry           = FALSE;
      941:  656:    uint32                                  ComputedCSValue         = 0;
        -:  657:    int32                                   Loop;
        -:  658:    uint32                                  EntireEepromCS;
        -:  659:    uint16                                  CurrEntry;
        -:  660:    int32                                   Status;
        -:  661:    
      941:  662:    if (CS_AppData.EepromCSState == CS_STATE_ENABLED)
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  663:    {                   
      719:  664:        if(CS_FindEnabledEepromEntry( &CurrEntry) == TRUE)
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
        -:  665:        {
        -:  666:            /* we found an enabled entry to checksum */
      697:  667:            StartOfResultsTable = CS_AppData.ResEepromTblPtr;   
      697:  668:            ResultsEntry = & StartOfResultsTable[ CurrEntry];
        -:  669:            
        -:  670:            /* If we complete an entry's checksum, this function will update it for us */
      697:  671:            Status = CS_ComputeEepromMemory (ResultsEntry, &ComputedCSValue, &DoneWithEntry);
call    0 returned 100%
        -:  672:            
        -:  673:            /* We need to avoid the case of finishing a table, moving on to the next one
        -:  674:             and computing an entry in that table, since it could put us above the 
        -:  675:             maximum bytes per cycle */
      697:  676:            DoneWithCycle = TRUE;
        -:  677:            
      697:  678:            if(Status == CS_ERROR)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  679:            {
        -:  680:                /* we had a miscompare */
        -:  681:                
        2:  682:                CS_AppData.EepromCSErrCounter++;                
        -:  683:                
        2:  684:                CFE_EVS_SendEvent (CS_EEPROM_MISCOMPARE_ERR_EID,
call    0 returned 100%
        -:  685:                                   CFE_EVS_ERROR,
        -:  686:                                   "Checksum Failure: Entry %d in Eeprom Table, Expected: 0x%08X, Calculated: 0x%08X",                                   
        -:  687:                                   CurrEntry,
        -:  688:                                   ResultsEntry -> ComparisonValue,
        -:  689:                                   ComputedCSValue);
        -:  690:            }
        -:  691:            
      697:  692:            if (DoneWithEntry == TRUE)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  693:            {
      697:  694:                CS_AppData.CurrentEntryInTable ++;
        -:  695:            }
        -:  696:                        
      697:  697:            if ( CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_EEPROM_TABLE_ENTRIES)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -:  698:            {   
        -:  699:                /* Since we are done CS'ing the entire Eeprom table, update the baseline 
        -:  700:                 number for telemetry */
       57:  701:                EntireEepromCS = 0;
      969:  702:                for (Loop = 0; Loop < CS_MAX_NUM_EEPROM_TABLE_ENTRIES; Loop++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  703:                {
      912:  704:                    EntireEepromCS += CS_AppData.ResEepromTblPtr[Loop].ComparisonValue;
        -:  705:                }
        -:  706:                
       57:  707:                CS_AppData.EepromBaseline = EntireEepromCS;
        -:  708:                
        -:  709:                /* We are done with this table */
       57:  710:                CS_GoToNextTable();
call    0 returned 100%
        -:  711:            }
        -:  712:        }
        -:  713:        else
        -:  714:        {
        -:  715:            /* If we don't have a full table, the above set of code won't get
        -:  716:             executed, so we do it if there aren't any more full entries left */
       22:  717:            if ( CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_EEPROM_TABLE_ENTRIES)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  718:            {   
        -:  719:                /* Since we are done CS'ing the entire Eeprom table, update the baseline 
        -:  720:                 number for telemetry */
       22:  721:                EntireEepromCS = 0;
      374:  722:                for (Loop = 0; Loop < CS_MAX_NUM_EEPROM_TABLE_ENTRIES; Loop++)
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  723:                {
      352:  724:                    EntireEepromCS += CS_AppData.ResEepromTblPtr[Loop].ComparisonValue;
        -:  725:                }                
       22:  726:                CS_AppData.EepromBaseline = EntireEepromCS;
        -:  727:            }
        -:  728:            
        -:  729:            /* There are no enabled entries in this table */
       22:  730:            CS_GoToNextTable();
call    0 returned 100%
        -:  731:        }
        -:  732:    }
        -:  733:    else /* Table is disabled, skip it */
        -:  734:    {
      222:  735:        CS_GoToNextTable();
call    0 returned 100%
        -:  736:    }
        -:  737:    
      941:  738:    return DoneWithCycle;
        -:  739:    
        -:  740:}/* end CS_BackgroundEeprom */  
        -:  741:
        -:  742:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  743:/*                                                                 */
        -:  744:/* Background check Memory                                         */
        -:  745:/*                                                                 */
        -:  746:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  747:boolean CS_BackgroundMemory(void)
function CS_BackgroundMemory called 885 returned 100% blocks executed 100%
      885:  748:{
        -:  749:    CS_Res_EepromMemory_Table_Entry_t     * StartOfResultsTable;
        -:  750:    CS_Res_EepromMemory_Table_Entry_t     * ResultsEntry;
      885:  751:    boolean                                 DoneWithCycle           = FALSE;
      885:  752:    boolean                                 DoneWithEntry           = FALSE;
      885:  753:    uint32                                  ComputedCSValue         = 0;
        -:  754:    uint16                                  CurrEntry;
        -:  755:    int32                                   Status;
        -:  756:    
      885:  757:    if (CS_AppData.MemoryCSState == CS_STATE_ENABLED)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  758:    {                   
        -:  759:        /* If we complete an entry's checksum, this function will update it for us */
        -:  760:        
      663:  761:        if (CS_FindEnabledMemoryEntry( &CurrEntry) == TRUE)
call    0 returned 100%
branch  1 taken 97% (fallthrough)
branch  2 taken 3%
        -:  762:        {
        -:  763:            /* we found an enabled entry to checksum */
      641:  764:            StartOfResultsTable = CS_AppData.ResMemoryTblPtr;   
      641:  765:            ResultsEntry = & StartOfResultsTable[ CurrEntry];
        -:  766:            
        -:  767:            /* If we complete an entry's checksum, this function will update it for us */
      641:  768:            Status = CS_ComputeEepromMemory (ResultsEntry, &ComputedCSValue, &DoneWithEntry);
call    0 returned 100%
        -:  769:            
        -:  770:            /* We need to avoid the case of finishing a table, moving on to the next one
        -:  771:             and computing an entry in that table, since it could put us above the 
        -:  772:             maximum bytes per cycle */
      641:  773:            DoneWithCycle = TRUE;
        -:  774:            
      641:  775:            if(Status == CS_ERROR)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  776:            {
        -:  777:                /* we had a miscompare */
        -:  778:                
        3:  779:                CS_AppData.MemoryCSErrCounter++;                
        -:  780:                
        3:  781:                CFE_EVS_SendEvent (CS_MEMORY_MISCOMPARE_ERR_EID,
call    0 returned 100%
        -:  782:                                   CFE_EVS_ERROR,
        -:  783:                                   "Checksum Failure: Entry %d in Memory Table, Expected: 0x%08X, Calculated: 0x%08X",                                   
        -:  784:                                   CurrEntry,
        -:  785:                                   ResultsEntry -> ComparisonValue,
        -:  786:                                   ComputedCSValue);
        -:  787:                 
        3:  788:                CS_AppData.CurrentEntryInTable ++;
        -:  789:            }
        -:  790:            
      641:  791:            if (DoneWithEntry == TRUE)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  792:            {
      641:  793:                CS_AppData.CurrentEntryInTable ++;
        -:  794:            }
        -:  795:            
      641:  796:            if ( CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_MEMORY_TABLE_ENTRIES)
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        -:  797:            {
        -:  798:                /* We are done with this table */
       57:  799:                CS_GoToNextTable();
call    0 returned 100%
        -:  800:            }
        -:  801:        }
        -:  802:        else /* since there aren't any enabled entries in this table, go to the next one */
        -:  803:        {
       22:  804:            CS_GoToNextTable();
call    0 returned 100%
        -:  805:        }
        -:  806:    }
        -:  807:    else /* Table is disabled, skip it */
        -:  808:    {
      222:  809:        CS_GoToNextTable();
call    0 returned 100%
        -:  810:    }
        -:  811:        
      885:  812:    return DoneWithCycle;
        -:  813:    
        -:  814:}/* end CS_BackgroundMemory */  
        -:  815:
        -:  816:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  817:/*                                                                 */
        -:  818:/* Background check Tables                                         */
        -:  819:/*                                                                 */
        -:  820:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  821:boolean CS_BackgroundTables(void)
function CS_BackgroundTables called 1087 returned 100% blocks executed 100%
     1087:  822:{
        -:  823:    CS_Res_Tables_Table_Entry_t           * StartOfTablesResultsTable;
        -:  824:    CS_Res_Tables_Table_Entry_t           * TablesResultsEntry;
     1087:  825:    boolean                                 DoneWithCycle           = FALSE;
     1087:  826:    boolean                                 DoneWithEntry           = FALSE;
     1087:  827:    uint32                                  ComputedCSValue         = 0;
        -:  828:    uint16                                  CurrEntry;
        -:  829:    int32                                   Status;
        -:  830:    
     1087:  831:    if (CS_AppData.TablesCSState == CS_STATE_ENABLED)
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
        -:  832:    {                                        
        -:  833:        /* If we complete an entry's checksum, this function will update it for us */
        -:  834:        
      864:  835:        if (CS_FindEnabledTablesEntry( &CurrEntry) == TRUE)
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
        -:  836:        {
        -:  837:            /* we found an enabled entry to checksum */
        -:  838:            
      815:  839:            StartOfTablesResultsTable = CS_AppData.ResTablesTblPtr;   
      815:  840:            TablesResultsEntry = & StartOfTablesResultsTable[ CurrEntry];
        -:  841:            
      815:  842:            Status = CS_ComputeTables (TablesResultsEntry, &ComputedCSValue, &DoneWithEntry);
call    0 returned 100%
        -:  843:            
        -:  844:            /* We need to avoid the case of finishing a table, moving on to the next one
        -:  845:             and computing an entry in that table, since  it could put us above the 
        -:  846:             maximum bytes per cycle */
      815:  847:            DoneWithCycle = TRUE;
        -:  848:            
      815:  849:            if(Status == CS_ERROR)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  850:            {
        -:  851:                /* we had a miscompare */
       24:  852:                CS_AppData.TablesCSErrCounter++;                
        -:  853:                
       24:  854:                CFE_EVS_SendEvent (CS_TABLES_MISCOMPARE_ERR_EID,
call    0 returned 100%
        -:  855:                                   CFE_EVS_ERROR,
        -:  856:                                   "Checksum Failure: Table %s, Expected: 0x%08X, Calculated: 0x%08X",                                   
        -:  857:                                   TablesResultsEntry -> Name,
        -:  858:                                   TablesResultsEntry -> ComparisonValue,
        -:  859:                                   ComputedCSValue);
        -:  860:            }
        -:  861:            
      815:  862:            if(Status == CS_ERR_NOT_FOUND)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  863:            {
        8:  864:                CFE_EVS_SendEvent (CS_COMPUTE_TABLES_NOT_FOUND_ERR_EID,
call    0 returned 100%
        -:  865:                                   CFE_EVS_ERROR,
        -:  866:                                   "Tables table computing: Table %s could not be found, skipping", 
        -:  867:                                   TablesResultsEntry -> Name);
        -:  868:                
        8:  869:                CS_AppData.CurrentEntryInTable ++;
        -:  870:            }
        -:  871:            
      815:  872:            if (DoneWithEntry == TRUE)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  873:            {
      807:  874:                CS_AppData.CurrentEntryInTable ++;
        -:  875:            }
        -:  876:            
      815:  877:            if ( CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_TABLES_TABLE_ENTRIES)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  878:            {
        -:  879:                /* We are done with this table */
       29:  880:                CS_GoToNextTable();
call    0 returned 100%
        -:  881:            }
        -:  882:        }
        -:  883:        else /* since there aren't any enabled entries in this table, go to the next one */
        -:  884:        {
       49:  885:            CS_GoToNextTable();
call    0 returned 100%
        -:  886:        }
        -:  887:    }
        -:  888:    else /* Table is disabled, skip it */
        -:  889:    {
      223:  890:        CS_GoToNextTable();
call    0 returned 100%
        -:  891:    }
        -:  892:    
     1087:  893:    return DoneWithCycle;
        -:  894:    
        -:  895:}/* end CS_BackgroundTables */
        -:  896:
        -:  897:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  898:/*                                                                 */
        -:  899:/* Background check App                                            */
        -:  900:/*                                                                 */
        -:  901:/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
        -:  902:boolean CS_BackgroundApp(void)
function CS_BackgroundApp called 1462 returned 100% blocks executed 100%
     1462:  903:{
        -:  904:    CS_Res_App_Table_Entry_t              * StartOfAppResultsTable;
        -:  905:    CS_Res_App_Table_Entry_t              * AppResultsEntry;   
     1462:  906:    boolean                                 DoneWithCycle           = FALSE;
     1462:  907:    boolean                                 DoneWithEntry           = FALSE;
     1462:  908:    uint32                                  ComputedCSValue         = 0;
        -:  909:    uint16                                  CurrEntry;
        -:  910:    int32                                   Status;
        -:  911:
     1462:  912:    if (CS_AppData.AppCSState == CS_STATE_ENABLED)
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
        -:  913:    {                    
     1239:  914:        if (CS_FindEnabledAppEntry( &CurrEntry) == TRUE)
call    0 returned 100%
branch  1 taken 94% (fallthrough)
branch  2 taken 6%
        -:  915:        {
        -:  916:            /* we found an enabled entry to checksum */
        -:  917:            
     1164:  918:            StartOfAppResultsTable = CS_AppData.ResAppTblPtr;   
     1164:  919:            AppResultsEntry = & StartOfAppResultsTable[  CurrEntry];
        -:  920:            
        -:  921:            /* If we complete an entry's checksum, this function will update it for us */
     1164:  922:            Status = CS_ComputeApp (AppResultsEntry, &ComputedCSValue, &DoneWithEntry);
call    0 returned 100%
        -:  923:            
        -:  924:            /* We need to avoid the case of finishing a table, moving on to the next one
        -:  925:             and computing an entry in that table, since it could put us above the 
        -:  926:             maximum bytes per cycle */
     1164:  927:            DoneWithCycle = TRUE;
        -:  928:            
     1164:  929:            if(Status == CS_ERROR)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  930:            {
        -:  931:                /* we had a miscompare */
        3:  932:                CS_AppData.AppCSErrCounter++;                
        -:  933:                
        3:  934:                CFE_EVS_SendEvent (CS_APP_MISCOMPARE_ERR_EID, CFE_EVS_ERROR,
call    0 returned 100%
        -:  935:                                   "Checksum Failure: Application %s, Expected: 0x%08X, Calculated: 0x%08X",                                   
        -:  936:                                   AppResultsEntry -> Name,
        -:  937:                                   AppResultsEntry -> ComparisonValue,
        -:  938:                                   ComputedCSValue);
        -:  939:            }
        -:  940:            
     1164:  941:            if(Status == CS_ERR_NOT_FOUND)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  942:            {
       50:  943:                CFE_EVS_SendEvent (CS_COMPUTE_APP_NOT_FOUND_ERR_EID,
call    0 returned 100%
        -:  944:                                   CFE_EVS_ERROR,
        -:  945:                                   "App table computing: App %s could not be found, skipping", 
        -:  946:                                   AppResultsEntry -> Name);
        -:  947:                
       50:  948:                CS_AppData.CurrentEntryInTable ++;
        -:  949:
        -:  950:            }
        -:  951:            
     1164:  952:            if (DoneWithEntry == TRUE)
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -:  953:            {
      557:  954:                CS_AppData.CurrentEntryInTable ++;
        -:  955:            }
        -:  956:            
     1164:  957:            if ( CS_AppData.CurrentEntryInTable >= CS_MAX_NUM_APP_TABLE_ENTRIES)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  958:            {
        -:  959:                /* We are done with this table */
        3:  960:                CS_GoToNextTable();
call    0 returned 100%
        -:  961:            }
        -:  962:        }
        -:  963:        else /* since there aren't any enabled entries in this table, go to the next one */
        -:  964:        {
       75:  965:            CS_GoToNextTable();
call    0 returned 100%
        -:  966:        }
        -:  967:    }
        -:  968:    else /* Table is disabled, skip it */
        -:  969:    {
      223:  970:        CS_GoToNextTable();
call    0 returned 100%
        -:  971:    }    
     1462:  972:    return DoneWithCycle;
        -:  973:    
        -:  974:}/* end CS_BackgroundApp */
        -:  975:
        -:  976:/************************/
        -:  977:/*  End of File Comment */
        -:  978:/************************/
